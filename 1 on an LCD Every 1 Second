.syntax unified 
.thumb 
.section .text 
.global main 
.type main, %function 
SIO_BASE    = 0xD0000000 
GPIO_OE_SET = 0x14 
GPIO_OE_CLR = 0x10 
GPIO_OUT_SET= 0x18 
GPIO_OUT_CLR= 0x1C 
TIMER_BASE  = 0x40054000       @ System timer 
TIMER_C1    = 0x10             
TIMER_CSR1  = 0x14 
@ C1 (compare) register 
@ Simplified LCD nibble write routine 
@ Input: r0 = nibble<<4 in bits [7:4], r1 = RS flag (0=data,1=cmd) 
lcd_write_nibble: 
@ Put data nibble onto GP0–3 
ldr r2, =SIO_BASE 
mov r3, r0 
str r3, [r2, #GPIO_OUT_CLR]  @ clear GP0–3 
str r3, [r2, #GPIO_OUT_SET]  @ set nibble on GP0–3 
@ Drive RS 
cmp r1, #0 
beq rs_cmd 
mov r3, #(1<<4) 
str r3, [r2, #GPIO_OUT_SET] 
b  continue 
rs_cmd: 
mov r3, #(1<<4) 
str r3, [r2, #GPIO_OUT_CLR] 
continue: 
@ Toggle E high→low 
mov r3, #(1<<5) 
str r3, [r2, #GPIO_OUT_SET] 
str r3, [r2, #GPIO_OUT_CLR] 
bx lr 
delay_1s: 
@ Read current timer low 32 bits 
ldr r0, [TIMER_BASE] 
add r0, r0, #125000000      
1: 
 @ +125 million cycles = 1 s @ 125 MHz 
ldr r1, [TIMER_BASE] 
cmp r1, r0 
blt 1b 
bx lr 
main: 
@ 1) Configure GPIO0–3,4,5 as outputs 
ldr r2, =SIO_BASE 
mov r3, #( (1<<0)|(1<<1)|(1<<2)|(1<<3)|(1<<4)|(1<<5) ) 
str r3, [r2, #GPIO_OE_SET] 
mov r4, #0      @ start with character '0' 
loop: 
@ 2) Send high nibble of ASCII('0' or '1') 
add r0, r4, #48 @ ASCII code into r0 
mov r1, #0      @ data mode 
lsr r5, r0, #4 
lsl r5, r5, #4 
bl  lcd_write_nibble 
@ 3) Send low nibble 
and r5, r0, #0x0F 
lsl r5, r5, #4 
bl  lcd_write_nibble 
@ 4) Wait 1 second 
bl  delay_1s 
@ 5) Toggle between 0 and 1 
eor r4, r4, #1 
b   loop 
.size main, .-main
